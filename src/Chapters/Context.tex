% Chapter Template

\chapter{Context handling} % Main chapter title

\label{ChapterContext} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{What is Context?}

A context, as far as Ohua is concerned, is a programming construct which changes the behavior of subsequent sections of code.
As an example the most basic context is the root context of an ohua \textt{algo} which changes the behavior of the functions within in so far as that they are executed once for each time the algo is executed.
Another example is the \texttt{smap} context which casues functions within to be executet multiple times.
Both of these contexts are control flow contexts which means they alter whether and how often functions are executed.
Most contexts in ohua are represented as a pair of encapsulating operators which mark the beginning and end of the context respectively.
The beginning marker sets up the altered behaviour and the end marker restores the original behavior.

In case of the \texttt{algo} context the \texttt{algo-in} as start operator starts the execution and the \texttt{algo-out} operator as end operator collects the result.
For \texttt{smap} the \texttt{smap} operator starts by executing the algorithm within once for each element in the structure being mapped and the \texttt{collect} operator restores the old behavior by waiting for as many elements as were in the mapped structure before returning the list to the next part of the program.

\subsection{The problem with context}


Control flow altering context such as smap or if pose a problem for yauhau.
Unlike in Haxl or Muse Yauhau uses compile time graph transformations to batch parallel fetch operations.
However are two fetches really parallel if one of them is in an if context and may not be executed at all?
A solution to this question could be to try and understand which fetch operations in a program are potentially parallel and use runtime scheduling to swap fetches in the accumulator.
This would not only incur additional runtime scheduling overhead but also if fetch f and fetch g are parallel and fetch f might not get executed there is no guarantee that there is another fetch h parallel to g which can be swapped in for f.

We chose a different strategy which can be implemented at compile time.
In order to batch two fetches we must simply guarantee that they in the same (control flow) context.
We can extend his principle and simplify by requiring all fetches in the program to be in the root context.

\subsubsection{}

An accumulator which is inserted into the program will only execute if all of its inputs, aka the request structures for all accumulated fetches, are present.
Therefore all fetches which combine into one accumulator are required to run the same number of times.
In a normal program the number of times a function is invoked depends on a number of ... things ... which alter the flow of control.
In our data flow graph sections with alternate control flow will always have a point of entry and a point of exit which surround a subgraph.
% TODO add why
Each operator within this subgraph is considered to be \textit{in} the context.


For simplicity we set this number to 1.
Our context transforations will guarantee all fetch operators will execute exacly once.


The reason for this is that a typical program contains parts which influence the flow of control in the program, such as conditionals and loops.
If a \fetch{} operation is located inside one such structure its invocation is not guaranteed anymore.
Accumulating parallel \fetch{} operations requires each of the requests to be present.
For a `flat` program structure, where no conditionals and loops are present, every operator will be guaranteed to be called once, and only once for every invokation of the program/function.
We require this property for all \fetch{} operations in order to batch them.
We define a context as a structure in the data flow graph which may change the flow of control in the program.
This can be something like a conditional statement which may run its branch or it may not or a mapping operation which will invoke the operators within any number of times.


%-----------------------------------
%	SUBSECTION 1
%-----------------------------------
\subsection{Definition}

We define

%-----------------------------------
%	SUBSECTION 2
%-----------------------------------
