%!TEX root = ../thesis.tex
\chapter{Extending the code generator}

\label{ch:extending-code-generator}

\section{Maps}

Adding meaningful mapping operations to the code generator is not trivial.
Meaningful mappings should be done over a large collection.
However at the present the code we generate does not produce large mappable structures.
It deals mostly with small numeric values to avoid having to deal with the type system too much when generating code.

\subsection{Current status}

The code generated by our generator is determined by two things

\begin{enumerate}
    \item \textbf{The label of the node} determines the type of function call the node will translate to.
          It holds potential extra information necessary for this type of function.
    \item \textbf{The successors} become the arguments to the function. Hence they control how many and which arguments a function receives.
\end{enumerate}

Return values of functions are never large mappable structures, as mentioned above.
Therefore we have to build mappable structures specially for map operations.
However the only data available to us to do that with are the successors to our node.
Therefore we could only build mappable structures as large as the number of successors to our node.
In order to attain reasonably sized programs however the number of successors a node can have is limited to a maximum of 6.
Lastly Ohua is currently unable to handle mapping over empty collections and also sometimes issues arise when mapping over collections of only one element.
This is not an issue for our experiments per se, since mappings over empty or one element structures provide no meaningful data to us anyways.
However we have to ensure that the generator tool does not generate maps over empty collections and for safety reasons also none for collections with only one element.

When the appropriate command line parameters are given the generator randomly assigns the \texttt{Map} computation type to nodes.
I tweaked the serialiser, which turns the graphs into actual source code to wrap the results from the successor nodes into a collection and generate a new independent function with which to map over the collection.
Furthermore the generator has been tweaked to fix the arity for independent functions which are used for mapping to 1\footnote{2 for Haxl since I also track an index to circumvent the implicit cache in Haxl which cannot be deactivated.}.
See produced code in Figure~\ref{fig:generated-map-code}.

\begin{figure}
\begingroup
\definecolor{green(html/cssgreen)}{rgb}{0.0, 0.5, 0.0}
\catcode`\@=\active
\def@#1@{\textcolor{green(html/cssgreen)}{#1}}
\begin{minted}[escapeinside=||]{Clojure}
(|@defalgo@| ifnlocal3 [param1]
    ...)
(defn main []
  (ohua
    (length (smap ifnlocal3 (vector local4 local5 local6)))))
\end{minted}
\endgroup
\begin{minted}{Haskell}
ifnlocal3 param1 = ...
main = do
    a <- fmap length (mapM ifnlocal3 [local4, local5, local6])
    return a
\end{minted}
\caption{Example for generated mapping code in Ohua and Haskell}
\label{fig:generated-map-code}
\end{figure}

\section{Conditionals}

\label{sec:extend-conditionals}

For our conditional experiments we need random programs in two different versions.
Explanation for why this is necessary can be found in Section~\ref{sec:precomp-eval}.

In one version computations on \texttt{then} and \texttt{else} branch of an \ifop{} are left in place, and in another the value of each branch is moved out of the branches and computed \emph{before} the \texttt{if} itself is evaluated.
In order to make this work with the current generator setup I changes how the branches of an if are handled.
Previously a conditional node would always have three successors.
The first one would become (part of) the condition.
Depending on the evaluation of the condition one of two branches would be selected, and each branch would contain a reference to the result of one of the other two successors respectively, see a schematic example in Figure~\ref{fig:old-if-serialisation}.

In order to get a full subgraph rather than just a reference onto these branches I changed the generator to generate two new functions per conditional node, one for the \emph{else}, one for the \emph{then} branch, see Figure~\ref{fig:new-precomp-if-serialisation}.
The first successor still becomes (part of) the condition but now each branch contains a function invocation to respectively one of the newly generated functions where the input parameters are all of the results from the successor nodes.

Now I can decide to either precompute the values for the branches by moving the function invocation out of the conditional statement, into a \texttt{let} binding, see Figure~\ref{fig:new-precomp-if-serialisation}.
Or alternatively put the function invocation in the conditional expression, see Figure~\ref{fig:new-inline-if-serialisation}.
In terms of batching opportunities calling functions on these branches is equivalent splicing a subgraph there because that basically how Ohua handles calling functions/\texttt{algo}s.
A new command line parameter was added to the generator which is used to select one of the two styles.

Apart from this difference (Figure~\ref{fig:new-precomp-if-serialisation} and Figure~\ref{fig:new-inline-if-serialisation}) the generated graphs and functions are identical.

\begin{figure}
\begin{minted}{Clojure}
(defn main []
  (ohua
    (let [local1 (...)
          local2 (...)
          local3 (...)]
      (if local1 local2 local3))))
\end{minted}

  \caption{Old serialisation for conditionals}
  \label{fig:old-if-serialisation}

\end{figure}

\begin{figure}
\begingroup
\definecolor{green(html/cssgreen)}{rgb}{0.0, 0.5, 0.0}
\catcode`\@=\active
\def@#1@{\textcolor{green(html/cssgreen)}{#1}}
\begin{minted}[escapeinside=||]{Clojure}
(|@defalgo@| ifnthenlocal4 [param1 param2 param3]
    ...)
(|@defalgo@| ifnelselocal4 [param1 param2 param3]
    ...)
(defn main []
  (ohua
    (let [local1 (...)
          local2 (...)
          local3 (...)]
      (let [thenlocal4 (ifnthenlocal4 local1 local2 local3)
            elselocal4 (ifnelselocal4 local1 local2 local3)]
        (if local1 thenlocal4 elselocal4)))))
\end{minted}
\endgroup
  \caption{New precomputed serialisation for conditionals}
  \label{fig:new-precomp-if-serialisation}
\end{figure}

\begin{figure}
\begingroup
\definecolor{green(html/cssgreen)}{rgb}{0.0, 0.5, 0.0}
\catcode`\@=\active
\def@#1@{\textcolor{green(html/cssgreen)}{#1}}
\begin{minted}[escapeinside=||]{Clojure}
(|@defalgo@| ifnthenlocal4 [param1 param2 param3]
    ...)
(|@defalgo@| ifnelselocal4 [param1 param2 param3]
    ...)
(defn main []
  (ohua
    (let [local1 (...)
          local2 (...)
          local3 (...)]
      (if local1
        (ifnthenlocal4 local1 local2 local3)
        (ifnelselocal4 local1 local2 local3)))))
\end{minted}
\endgroup
  \caption{New inline serialisation for conditionals}
  \label{fig:new-inline-if-serialisation}
\end{figure}
