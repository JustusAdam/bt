\chapter{Extending the code generator}

\label{ch:extending-code-generator}

\section{Maps}

Adding meaningful mapping operations to is difficult.
Meaningful mappings should be done over a large collection.
However at the present the code we generate does not produce large mappable structures.
It deals mostly with small numbers to avoid having to deal with the type system too much when generating code.

\subsection{Current status}

The code generated by our generator is determined by two things

\begin{enumerate}
    \item \textbf{The label of the node} determines the type of function call the node will be compile to.
          It holds potential extra information necessary for this type of function.
    \item \textbf{The successors} become the arguments to the function. Hence they control how many and which arguments a function receives.
\end{enumerate}

Return values of functions are never large mappable structures, as mentioned above.
Therefore we have to build mappable structures specially for map operations.
However the only data available to us to do that with are the successors to our node.
Therefore we could only build mappable structures as large as the number of successors to our node.
In order to attain reasonably sized programs however the number of successors a node can have is limited to a maximum of 6.
Lastly Ohua is currently unable to handle mapping over empty collections, therefore we have to ensure that the generator tool does not generate maps over empty collections.

When the appropriate command line parameters are given the generator randomly assigns the \texttt{Map} computation type to nodes.
I have now tweaked the serialiser, which turns the graphs into actual source code to wrap the successors of the node into collections and generate a new independent function with which to map over the collection.
Furthermore the generator has been tweaked to fix the arity for independent functions which are used for mapping to 1.
This restriction is necessary since neither Haskell nor Ohua, our two main targets for code generation support multiple arity mapping.
See produced code in Figure~\ref{fig:generated-map-code}. 

\begin{figure}
\begin{minted}{Clojure}
(defalgo ifnlocal3 [param1]
    ...)
(defn main []
  (ohua
    (length (smap ifnlocal3 (vector local4 local5 local6)))))
\end{minted}
\begin{minted}{Haskell}
ifnlocal3 param1 = ...
main = do
    length <$> mapM ifnlocal3 [local4, local5, local6]
\end{minted}
\caption{Example for generated mapping code in Ohua and Haskell}
\label{fig:generated-map-code}
\end{figure}
