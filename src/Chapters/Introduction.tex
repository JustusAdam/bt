%!TEX root = ../thesis.tex
\chapter{Introduction}

\label{ch:Intro}


% TODO the intro is a bit twisted: normally an intro goes by this structure: problem, missing solutions, contributions, outline (I like it when the last two are co-mingled.)

In the paper ``Ÿauhau: Concise Code and Efficient I/O Straight from\-Dataflow.''\cite{ErtelGoensAdamEtAl2016}, authored by Sebastian Ertel, Andrés Goens, Jeronimo Castrillon and myself, \yauhau{}, a plugin for the Ohua\cite{Ertel:2015:OID:2807426.2807431}\cite{Ohua:library:link} compiler, was introduced.
\yauhau{} rewrites a program to achieve efficient I/O whilst allowing the programmer to write very concise and straight forward code.
It is inspired by a similar system called Haxl, see Chapter~\ref{ch:related-work}.
In the paper we explained the basic idea of finding data independent, reading I/O actions, combining them into batched requests, caching them as well as executing them concurrently.

\section{Contributions}

\begin{enumerate}
    \item Because of our compile time transformation model \yauhau{} faces challenges when confronted with control flow structures such as \texttt{if} and iteration in the form of a mapping operation called \texttt{smap}.
    The basic implementation of these rewrites was done already for the paper, however no detailed description has yet been provided due to constraints for content length.
    Therefore this thesis provides such a detailed description, including implementation considerations and decisions, of the \textbf{if and smap transformations}.
    \item Born of the necessity to handle nested \texttt{smap}s and \texttt{if}s in our rewrites I present a generalisation of non structurally emergent dataflow graph properties into a concept called \textbf{Context}.
    Contexts are a broader concept which transcends the scope of only the control flow structures \texttt{if} and \texttt{smap} and is now a part of the Ohua framework.
    In this thesis I will define contexts, describe general properties, how it is detected and how it is used to handle nested control flow in \yauhau{}.
    \item The aforementioned paper also introduces the notion of a mutative I/O action in the form of \texttt{write} requests.
    We already explained how we ensure results of mutative actions are visible to the \texttt{read} requests in the presence of a cache, however there is still more semantic consistency to be desired between \texttt{read} and \texttt{write} requests.
    Namely that when algorithm\footnote{An ``algorithm'' is like a function in the Ohua framework, see Chapter~\ref{ch:Ohua}.} $a$ depends on the result of running algorithm $b$, all reads and writes in $b$ should be performed before reads or writes in $a$ are performed.
    I provide an optional graph transformation in \yauhau{} used to \textbf{preserve write semantics} in programs using the \yauhau{} batching.
    \item \textbf{Extensions to the random code generator}~\cite{Goens-rand-code-graph} used in the \yauhau{} paper to generate test programs.
    These extenstions enable \textbf{support for mapping operations} as well as different \textbf{generation methods for conditionals} in the code generator.
    \item Using the new extensions we can generate programs with certain properties, namely a certain percentage of map applications and/or conditional nodes.
    As a result I can now show new \textbf{experiments} comparing the performance of the \yauhau{} plugin to the existing technology Haxl in \textbf{programs with conditionals and mapping}.
    \item Lastly I explore the possibility of \textbf{optimising programs for faster I/O by precomputing branches} of a conditional (\texttt{if}).
    I show experimental comparisons of the number of performed rounds and fetches in programs with both precomputed and non-precomputed conditionals.
\end{enumerate}

% \begin{itemize}
%     \item A more detailed description, including implementation considerations and decisions, of the \textbf{if and smap transformations}.
%     \item The generalisation of non structurally emergent dataflow graph properties into a concept called \textbf{Context}, its detection and use to handle nested control flow in \yauhau{}.
%     \item An optional graph transformation in \yauhau{} used to \textbf{preserve write semantics} in programs using the \yauhau{} batching.
%     \item An evaluation of the effect of precomputed conditional branches on latency.
%     \item New \textbf{experiments} showing the performance of the \yauhau{} plugin in comparison to the existing technologies Haxl and Muse in \textbf{programs with conditionals and mapping}.
%     \item \textbf{Extensions to the random code generator}~\cite{Goens-rand-code-graph} used in the \yauhau{} paper to generate test programs.
%     These extenstions enable \textbf{support for mapping operations} as well as different \textbf{generation methods for conditionals} in the code generator.
% \end{itemize}

%
% This thesis intends to improve on the current implementation of this plugin, provide explanation as to why adjustments to the implemetation are necessary in the first place, document adjustments made to the Ohua core which enable the plugin to function and finally expand on the experimental evaluation started in the paper, providing comparative data for performance of our plugin against frameworks with similar functionality.
%
% \section{Fundamental Technologies}
%
% This section shall serve as a reference for technologies which this thesis and its implementation is based upon.
% After this section I presume the reader to be familiar with these technologies and concepts and shall not provide further explanation.
%
% \subsection{Clojure}
%
% Clojure is a functional, dynamically typed language targeting the JVM  which we use to express the higher level algorithms in Ohua.
% Bejond that I use Clojure to implement most of the compiler internal algorithms, including those described in this thesis.
% There will occasionally be code examples to illustrate certain algorithms I am describing, those will usually be written in the Clojure language.
%
% \subsection{Ohua}
%
% Ohua is an automated parallelization framework which combines low level efficiency as provided by the JVM with high level expressions as found in the clojure programming language.
% In Ohua algorithms are implemented in the expressive clojure language and in terms of so called stateful functions, performant and state heavy java code pieces.
% Algorithms implemented in this way will can be automatically disassembled into a data flow graph and parallelized by the Ohua runtime and scheduler.
