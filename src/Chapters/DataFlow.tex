% Chapter Template

\chapter{Selected data flow fundamentals} % Main chapter title

\label{ChapterDataFlow}

\section{Graph representation}

Ohua was already using a data flow graph for its runtime execution model, but in order to implement Yauhau we also needed a (much simpler) compile time data flow graph representation.
The ohua compiler now contains a compile time intermediate representation (IR) of the program.
This IR encodes the data flow relationships inside the algorithm.
It is designed to resemble the program as it would be written by a person to make it easier to read.
The description of the graph contains two basic elements:
\begin{enumerate}
    \item \textbf{Bindings} are named data elements or alternatively can be interpreted as a data path. Each binding has to be unique, which means it can only be assigned to once, in which case we also speak of the \textit{creation} of the binding or of \textit{writing} the binding. However the binding may be read any number of times (including 0).
    \item \textbf{(Stateful)Functions} are atomic pieces of code. They are characterized by a function name which doubles as a reference to the code itself, its input parameters as a list of bindings and its return values, also a list of bindings.
    This might be more analogous to a call site or function invocation in traditional jargon.
    If a binding is present in a parameter list we also speak of the binding being \textit{read}.
    Is the binding present in the return value list we also speak of the binding being \textit{written} or \textit{created}\footnote{Due to the uniqueness constraint \textit{writing} and \textit{creating} are the same here.}.
\end{enumerate}

\subsection{Implementation}

The actual implementation of the graph is simply a list of functions. Each function is a Clojure record with fields for an optional id, the name of the function, a vector of input bindings and a binding or a vector of bindings as return values.

\begin{minted}{Clojure}
(defrecord IRFunc [id name args return])

(def graph
    [(->IRFunc nil "f" ['a 'b] 'c)
     (->IRFunc nil "g" ['c] ['d 'e])])

\end{minted}

This can be interpreted like a clojure let binding using destructuring.

\begin{minted}{Clojure}
(let [c (f a b)
      [d e] (g c)])
\end{minted}

\subsection{Interpretation}

The aforementioned graph implementation can be interpreted as a DAG.
The direction is given by the flow of data, from output to input.
The graphs have to be acyclic.
This is a restriction currently imposed by the underlying Ohua framework but it is also embraced by the algorithms in this thesis because it allows simpler implementations.
Functions are nodes.
I hereby mean a function as a concrete invocation including input and output bindings.
This is in contrast to \textit{function names} which are simply labels to the node describing its functionality.
Bindings are edges.
Each named binding can represent or indicate multiple or no edges.
Bindings are \textit{write once}, hence any binding may only occur once as a return value but may be used an arbitrary number of times as input value.
As a result all edges represented by a particular binding originate from the same node.
Furthermore the graph must be complete, as in any binding read must have previously been written.
For each time a binding is read it represents an edge from its source node to the reading node.
Thus a binding which is never read creates no edges.
