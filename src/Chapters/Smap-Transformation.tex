%!TEX root = ../thesis.tex
\chapter{Smap Transformation}

\label{ch:smap-transformation}

\section{Simplified}

Aim of the smap transformation step is to merge a bounded number of fetches into a single fetch.
How many times the fetch would be executed is not known at compile time but only given at runtime by the length of the collection which is being mapped over.
Basis for the transformation itself is that a mapping operation over two composed functions is semantically identical to the composition of one mapping operation with one function each, in the same order.

\begin{verbatim}
map (f . g) == map f . map g
\end{verbatim}

The basic transformation steps can be described as follows:

The function inside the map is separated into a computation before the fetch, the fetch, and a computation after the fetch, see \texttt{decomposed} in Figure~\ref{fig:map-decomposition-in-code}.
Since there may be data flowing from \texttt{before} to \texttt{after} which does not pass through the \texttt{fetch} we choose \texttt{before} and \texttt{after} such that \texttt{before} returns a tuple where the first part of the tuple contains only the data our fetch can operate on and the second part of the tuple contains any additional data which needs to flow between \texttt{before} and \texttt{after}.
\texttt{after} then accepts a tuple where the first part is the result of executing the fetch and the second part is the untouched additional data flowing between \texttt{before} and \texttt{after}.
In the middle we apply the fetch function to only the first part of the tuple with the higher order function \texttt{first}.

\begin{figure}
\begin{minted}{Haskell}
fetchMany :: [FetchData] -> [FetchResult]
fetchMany = -- omitted

original :: forall a b. [a] -> [b]
original = map f
    where f :: a -> b
          f = -- omitted

decomposed :: forall a b free. [a] -> [b]
decomposed = map (after . first fetch . before)
    where before :: a -> (FetchData, free)
          before = -- omitted

          fetch :: FetchData -> FetchResult
          fetch = -- omitted

          after :: (FetchResult, free)
          after = -- omitted

fission :: forall a b free. [a] -> [b]
fission =
    (map after :: [(FetchResult, free)] -> [b])
    . (map (first fetch) :: [(FetchData, c)] -> [(FetchResult, c)])
    . (map before :: [a] -> [(FetchData, free)])
    where ...

unzipped :: forall a b free. [a] -> [b]
unzipped =
    map after
    . (uncurry zip :: ([c], [d]) -> [(c, d)])
    . (first
        (map fetch :: [FetchData] -> [FetchResult])
        :: ([FetchData], g) -> ([FetchResult], g))
    . (unzip :: [(e, f)] -> ([e], [f]))
    . map before
    where ...

replaced :: forall a b free. [a] -> [b]
replaced =
    map after
    . uncurry zip
    . first fetchMany
    . unzip
    . map before
\end{minted}
\caption{Decomposing maps in Haskell}
\label{fig:map-decomposition-in-code}
\end{figure}


\section{Implementation detail}

The simplified explanation above is, albeit a nice and easy example, wrong.
Unfortunately, although it handles the case above correctly, it does not handle the general case correctly.
Not every computation is a simple pipeline, like displayed there, and thus could be broken into those three separate functions.
% A general case could be displayed using a tuple of the data for the fetch and the rest of the flowing data, like so
% map after . map (first fetch) . map before
% and then
% map after . uncurry zip . first (map fetch) . unzip . map before
We operate not in a normal programming language but on a dataflow graph which, in this case, is more powerful.
As a consequence we can separate out the fetch, wrap it, like described above, and batch it, even if there is other data flowing from \texttt{before} to \texttt{after} which does not pass through the \fetch{}.

On the dataflow IR we don't work with Clojure functions but with graph nodes, which could also be interpreted as operators.
The splitting is therefore not done with maps, but special nodes which start and end a mapping operation in Ohua.
The Ohua mapping operation is called \texttt{smap} and consists at IR level of several operators, the two interesting ones being \texttt{smap} (internally called \texttt{smap-fun}) and \texttt{collect}.
\texttt{smap} is the starting operator and provides the mapping functionality by continuously emitting items from a collection until the collection is empty.
\texttt{collect} is the opposite and only receives items until the collection is rebuilt.
Both also obtain information such as the size of the collection in order to function correctly.

The \texttt{smap} transformation as implemented in \yauhau{} simply inserts a collect operator before the fetch to rebuild the collection and a tree builder node to wrap it.
The collect operator is also fed the size of the original collection.
A new \texttt{smap} operator is inserted after the fetch to break the list into items again and continue the mapping.
A graphical example of this can be seen in Figure \ref{ch:smap-transformation}.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{Figures/smap-rewrite-original}
	\includegraphics[width=\textwidth]{Figures/smap-rewrite}
	\label{fig:smap-transformation}
	\caption{Smap transformation}
\end{figure}

\section{Encoding}

The structure of the nested smap is saved in a tree structure.
We use an unlabeled rose tree\cite{MALCOLM1990255}.
It is important to use a tree structure because we would like to be able to support arbitrarily deep levels of nesting.
A rose tree can easily be flattened into a list and be reconstructed into a tree.
The Java programmer will recognise the Composite Pattern\cite{gamma1995design} in the definition of our tree, which comprises of an abstract tree base class, Figure \ref{fig:tree-impl-base-class}.

\begin{figure}

\begin{minted}{Java}
public abstract class RequestTree {
    public abstract
    Stream<Request> getRequestsStream();

    public abstract
    Iterable<Object>
    buildResult(Map<Request, Object> responses);
}
\end{minted}
\caption{Abstract base class}
\label{fig:tree-impl-base-class}

\end{figure}

The basic tree offers methods to access all contained requests as a flat stream as well as a method for constructing a nested tree structure of results mirroring the structure of the request tree itself.
Our tree is composed of unlabeled branches which hold a sequence of subtrees as seen in Figure \ref{fig:tree-impl-branch}.
In this case the flat request stream simply comprises of the concatenation of all requests from the subtrees.
In this way we don't need any further knowledge of the structure of those subtrees to obtain the requests.
Although this structure is technically capable of handling a heterogeneous list of subtrees in practice, as a result of how these trees are created all subtrees have the same height and structure.

\begin{figure}

\begin{minted}{Java}
public final class RequestTreeBranch
             extends RequestTree {
    private final Iterable<RequestTree> subtrees;
    @Override
    public Stream<Request> getRequestsStream() {
        return StreamSupport
                  .stream(subtrees.spliterator(), false)
                  .flatMap(RequestTree::getRequestsStream);
    }

    @Override
    public
    Iterable<Object>
    buildResult(Map<Request, Object> responses) {
        return StreamSupport
                  .stream(subtrees.spliterator(), false)
                  .map(t -> t.buildResult(responses))
                  .collect(Collectors.toList());
    }
    /* omitted code */
}
\end{minted}
\caption{Concrete branch}
\label{fig:tree-impl-branch}

\end{figure}


\begin{figure}

\begin{minted}{Java}
public final class Request<P, R>
             extends RequestTree {
    @Override
    public Stream<Request> getRequestsStream() {
        return Collections
                 .singletonList((Request) this)
                 .stream();
    }

    @Override
    public
    Iterable<Object>
    buildResult(Map<Request, Object> responses) {
        return Collections.singletonList(responses.get(this));
    }
    /* omitted code */
}
\end{minted}

\caption{Request class}
\label{fig:tree-impl-request-class}
\end{figure}

Lastly our leaf nodes are simply requests, as the basic \texttt{Request} also extends the \texttt{RequestTree}, Figure \ref{fig:tree-impl-request-class}.

This rose tree encodes, in a data structure, the nested structure of the smap context.
The height of the tree equals the depth of smap nesting that was encoded.

% TODO explain why rose tree
